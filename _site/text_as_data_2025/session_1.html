<!DOCTYPE html>
<html lang="eng">
    <head>
	<title>Teaching</title>
	<link rel="stylesheet" href="style.css">
        <link href="https://fonts.googleapis.com/css?family=Roboto:100,200,300,400" rel="stylesheet">
        <!-- Prism.js for syntax highlighting -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
    </head>
    <body>
	<h1>AYAN-YUE GUPTA</h1>
        
	<!-- navigation-->
        <div class="links">
            <a href="/index.html">Home</a>
	    <a href="/research.html">Research</a>
	    <a href="/teaching.html">Teaching</a>
	    <a href="/art.html">Art</a>
	    <a href="/assets/CV.pdf">C.V.</a>
	</div>

	<!-- content-->
        <div class="container">
	    
            <!-- table of contents -->
            <div id="top" class="container">
                <h2 class="contents_title">~ ~ ~ ~ Table of Contents ~ ~ ~ ~</h2>
                <ul class="contents_table">
                    <li><a href="#setup">1. Setting up your work environment</a></li>
                    <li><a href="#first-script">2. Your first script</a></li>
                    <li><a href="#basics">3. Basics: variables, functions, types</a></li>
                    <li><a href="#organization">4. Keeping code organised</a></li>
		    <li><a href="#imports">5. Imports</a></li>
		    <li><a href="#data_examination">6. Examining the data</a></li>
		    <li><a href="#data_structures">7. Structuring the data</a></li>
                </ul>
            </div>


        <h2 id="setup">1. Setting up your work environment</h2>
        <p>Hello everyone. The first thing to do when getting started with coding in Python is to understand how everything is set up. There are lots of options for integrated development environments and notebooks one can use, but before exploring those options, one should know the most basic set up possible, for which you need just 2 things:</p>
	<ul class="research">
	    <li>Text editor</li>
	    <li>Command line</li>
        </ul>
	<p>We'll be using this minimal set up for the rest of my sessions.</p>
        <p>Now, if you've followed the setup for this session, you should already have Python installed and have selected a text editor. The next thing to do is to set up a virtual environment. Knowing how to manage virtual environments is useful because dealing with multiple Python projects can get messy. One project might require an older version of a particular programme, while another project you are working might require a newer version of the same programme. Instead of upgrading/reverting programme versions everytime you want to work on different Python projects, virtual environments lets you work with different versions of required programmes simultaneously.</p>
	<p>To set up a virtual environment, follow these steps:</p>
        <ul class="research">
	    <li>(1) Choose or create a folder where you want your virtual environment to be. For example, you might choose or create the folder in the location <code>C:\Users\YourUsername\Documents\Projects\my_python_project</code></li>
            <li>(2) Open your command line (command prompt in Windows, terminal in MacOS and Linux) and use the <code>cd</code> command to navigate to the folder you created in (1), for example:<pre><code class="language-bash">cd C:\Users\YourUsername\Documents\Projects\my_python_project</code></pre></li>
            <li>(3) Use the following command to create a virtual environment named <code>env1</code>:<pre><code class="language-bash">python -m venv env1</code></pre>
        </ul>
	<p>You now have a virtual environment called <code>env1</code> in the folder you selected/created in (1). You should get into the habit of navigating to the directory of your environment and activating it whenever you want to work on a Python project with the following commands:</p>
        <pre><code class="language-bash">#### navigate to the directory containing your virtual environment
cd \Users\YourUsername\Documents\Projects\your_python_project

#### activate your virtual environment
#### Mac/Linux
source env1/bin/activate
#### Windows
env1\Scripts\activate</code></pre>
	<p>To deactivate your virtual environment, simply enter:<pre><code class="language-bash">deactivate</code></pre></p>
        <div class="back-to-top"><a href="#top">↑ Back to top</a></div>


	<h2 id="first-script">2. Your first script</h2>
        <p>You are now in a position to write your first script! Using your text editor, create a file called <code>first_script.py</code> in the same directory containing your virtual environment. With your text editor, enter the following line into <code>first_script.py </code>:</p>
	<pre><code class="language-python">print('hello')</code></pre>
        <p>Save your file, and in the command line (ensuring you are in the same directory as <code>first_script.py</code>), and enter the command:</p>
	<pre><code class="language-bash">python first_script.py</code></pre>
        <p>You should get the following output in your command line:</p>
	<pre><code class="language-bash">>>> hello</code></pre>
        <p>Congratulations on your first script! Note the workflow here: create script with text editor, save as <code>.py</code> file, run the file in command line. This is the fundamental process of using Python.</p>
        <div class="back-to-top"><a href="#top">↑ Back to top</a></div>
	   

	<h2 id="basics">3. Basics: variables, functions, types</h2> 
        <p>If we want to make scripts that can do a bit more than just print text, we need to make sure our code is organised so that:</p>
        <ul class="research">
            <li>Code is legible, meaning we aren't spending 10 minutes every time we need to find some section of code that needs editing.</li>
	    <li>We are not constantly rewriting the same bit of code everywhere</li>
	</ul>
        <p>Scripts can get pretty complicated very quickly. Without keeping things organised, scripts that can do more complex tasks can become a nightmare to read through and maintain.</p>
	<p>The basic tool for ensuring good organisation is the <i>function</i>. Functions allow us to package code we know we are going to use repeatedly in a neat way, and to enable that bit of repeatable code to work with many different inputs. For example, suppose in our script we know we are going to be printing a lot of similar stuff. Instead of rewriting the various combinations of what we want to print repeatedly, we can define a single function that gives us a basic template of what we want to print:</p>
        <pre><code class="language-python">def greetings(name, country):
    
    print(f'Hello, my name is {name} and I am from {country}.')</code></pre>
	<p>Here, we give the name and country of our greeting as <i>arguments</i>. Now, whenever we want our script to introduce a different person, instead of repeatedly typing out variations of the greeting, we can simply call the function with different arguments:</p>
        <pre><code class="language-python">greetings('John', 'Great Britain')
greetings('Monica', 'Italy')</code></pre>
        <p>Note the formatting used to define the function. After the first line defining function arguments, the rest of the function is indented 4 spaces to the right. Remember this indentation format -- whenever one indents in Python, one indents with 4 spaces.</p>
	<p>You'll notice that if we do not put the arguments of <code>greetings()</code> in quotation marks, the code will not work. This is because Python is structured around the idea of <i>types</i> of values. In Python, values can be:</p>
	<ul class="research">
            <li><code>str</code> (strings): Text values like 'John' or "Hello world"</li>
            <li><code>int</code> (integers): Whole numbers like 42 or -7</li>
            <li><code>float</code> (floating point): Decimal numbers like 3.14 or -0.001</li>
	    <li><code>bool</code> (boolean): True or False values</li>
	    <li><code>list</code>, <code>dict</code>, <code>tuple</code>: Different ways to organize collections of values</li>
	</ul>
        <p>When we put text in quotation marks, we're creating a string value. Without the quotation marks, Python would think we're trying to refer to a <i>variable</i> called 'John', which doesn't exist in our code.</p>
	<p>Variables are names that refer to stored values. Think of them as labeled containers that hold data. For example:</p>
	    <pre><code class="language-python">name = "John"
age = 25
height = 1.85
countries_visited = ["France", "Japan", "Brazil"]</code></pre>
        <p>Here, <code>name</code>, <code>age</code>, <code>height</code>, and <code>countries_visited</code> are variables that store different types of values. We can use these variables in our functions:</p>
        <pre><code class="language-python">person_name = "Monica"
person_country = "Italy"
greetings(person_name, person_country)</code></pre>
        <p>This will produce the same output as <code>greetings('Monica', 'Italy')</code> because the variables contain those string values.</p>
        <p>Understanding value types and variables is crucial because Python treats different types differently. For example, the <code>+</code> operator adds numbers but concatenates strings:</p>
        <pre><code class="language-python">result1 = 5 + 10       # result1 equals 15
result2 = "5" + "10"   # result2 equals "510"</code></pre>
        <div class="back-to-top"><a href="#top">↑ Back to top</a></div>


        <h2 id="organization">4. Keeping code organised</h2>
        <p>To ensure organisation, it's a good idea to make sure your scripts always have this structure:</p>
        <pre><code class="language-python">#### write imports at the beginning, e.g.:
import os

#### write functions and classes here, e.g.:
def function(arg):
    
    return arg * 2
  

def main():

    ####call functions and classes here, e.g.:
    function(2)

if __name__ == '__main__':
    main()</code></pre>
	<p>Do not worry about what imports are for now - we'll cover those in 5 minutes. The key parts to understand in this structure are:</p>
	<ul class="research">
	    <li>Imports go at the top of the file</li>
            <li>Function definitions come next</li> 
	    <li>The <code>main()</code> function contains the code that actually runs when you execute the script</li>
	    <li>The <code>if __name__ == '__main__'</code> line is a special Python construct that ensures your code only runs when the script is executed directly (not when imported by another script)</li>
	</ul>
	<p>Let's modify our first script to follow this pattern:</p>
        <pre><code class="language-python">def greetings(name, country):
    print(f'Hello, my name is {name} and I am from {country}.')

def main():
    greetings('John', 'Great Britain')
    greetings('Monica', 'Italy')

if __name__ == '__main__':
    main()</code></pre>
	<p>When you run this script, it will produce exactly the same output as before, but is now organised in a way that makes it much easier to maintain and update, since now you know where functions are defined, where functions are called and where imports are performed. This structure will become especially valuable as your scripts grow larger and more complex.</p>
        <div class="back-to-top"><a href="#top">↑ Back to top</a></div>
        
    
        <h2 id="imports">5. Imports</h2>
	<p>In Python scripts, we can import other Python scripts -- known as packages -- written by other people. This makes life much easier. It means that we do not have to, for example, write a neural network from scratch everytime we want to do some machine learning. We can just import an appropriate network that someone else has written.</p>
	<p>Before we can import a package, we need to install it into our virtual environment. There are multiple 'package managers' that enable you to install packages. In my sessions, we will only be using the default package manager, <code>pip</code>.
	<p>Let us use <code>pip</code> to install <code>nltk</code>, the Natural Language Toolkit. This package will help us learn the basics of using text as data:</p>
	<pre><code class="language-bash">pip install nltk</code></pre>
	<p>Now, create a new python script in your Python project directory entitled <code>preprocessing.py</code> using your text editor. In the way just discussed, add in the <code>main</code> function and <code>if __name__ == '__main__':</code> block to keep things organised. We can use <code>pass</code> as a placeholder before adding in function calls to <code>main</code>. At the very top of the script, let us import <code>nltk</code>:</p>
        <pre><code class="language-python">import nltk

def main():
    
    pass ####placeholder -- we can remove this when we start adding stuff to main()


if __name__ == '__main__:
    main()</code></pre>
	<p>We will be using a movie review dataset downloadable from <code>nltk</code> to learn text preprocessing. With <code>nltk</code>, we sometimes need to download additional resources to import <code>nltk</code> packages that don't come with the initial <code>nltk</code> installation. We can use the <code>nltk.download()</code> function to download these additional resources. We will use this function to download the resources needed to import the 'movie_reviews' dataset:</p>
        <pre><code class="language-python">import nltk
nltk.download('movie_reviews')
from nltk.corpus import movie_reviews

def main():
    
    pass ####placeholder -- we can remove this when we start adding stuff to main()


if __name__ == '__main__:
    main()</code></pre>
	<p>When we use <code>from nltk.corpus import movie_reviews</code>, we're using a more specific import syntax that lets us import just one particular component from a package. This differs from <code>import nltk</code>, which imports the entire package. The advantage of using <code>from x import y</code> is that we can directly use the imported component without having to prefix it with the package name. So, we can now write <code>movie_reviews</code> instead of having to prefix with <code>nltk.corpus</code> all the time: <code>nltk.corpus.movie_reviews</code>. This keeps our code concise.</p>
        <div class="back-to-top"><a href="#top">↑ Back to top</a></div>


       <h2 id="data_examination">6. Examining the data</h2>
	<p>So we've managed to import some movie review data to practise preprocessing. But we have no concrete understanding of the data. What does it look like? The movie_reviews dataset is stored as a <i>class</i>. We will not go into the details of classes now -- if we have time, we will go through them in one of the other 2 sessions. For now, it is enough to say that a class is a way of bundling together a collection of related functions. These functions are known as the <i>methods</i> of a class. So, the data of movie_reviews is accessible through movie_reviews' methods. Let's print the output of some of these methods to see what's going on:</p>
        <pre><code class="language-python">import nltk
nltk.download('movie_reviews')
from nltk.corpus import movie_reviews

def main():
    
    print(movie_reviews.fileids('pos'))
    print(movie_reviews.fileids('neg'))

if __name__ == '__main__:
    main()</code></pre>
	<p>As you can see, we get a long list of strings, where each string is some kind of file path. Let's write a loop and use movie_reviews' <code>.words()</code> method to see what's inside these files:</p>
        <pre><code class="language-python">import nltk
nltk.download('movie_reviews')
from nltk.corpus import movie_reviews

def main():
    
#    print(movie_reviews.fileids('pos'))
#    print(movie_reviews.fileids('neg'))
    file_ids = movie_reviews.fileids('pos') + movie_reviews.fileids('neg')
    for file_id in file_ids:
        print(movie_reviews.words(file_id))
    
if __name__ == '__main__:
    main()</code></pre>
        <p>You'll notice that I've added some lines starting with <code>#</code> at the beginning of the main function in the code above. The <code>#</code> symbol is how we create comments in Python. Any text that follows a <code>#</code> on a line is ignored by Python when running the script. Comments are useful for temporarily disabling code without deleting it (as I've done with our previous print statements)and leaving notes for yourself or other programmers who might read your code later.</p>
	<p>Running this code prints out the contents of each file as a list of words. Just by using some print statements and loops, we can get more of a feel of how the movie_reviews dataset is organised in terms of file ids that can be used with movie_reviews' methods to get the dataset's contents. This process of getting to grips with the structure and contents of a dataset by basically using loops and print statements is an important part of getting a concrete, intuitive picture of what's going on.</p>
        <div class="back-to-top"><a href="#top">↑ Back to top</a></div>


        <h2 id="data_structures">7. Structuring the data</h2>
	<p>Through the previous section, we have gained some familiarity with lists. We can tell a value is a list by looking at its brackets -- if it is enclosed with square brackets <code>[]</code>, it is a list. We can use <i>slicing and indexing</i> to look at parts of lists. For example, we can modify the our loop printing the contents of the movie_reviews dataset to only print the first 5 words of each review:
        <pre><code class="language-python">import nltk
nltk.download('movie_reviews')
from nltk.corpus import movie_reviews

def main():
    
#    print(movie_reviews.fileids('pos'))
#    print(movie_reviews.fileids('neg'))
    file_ids = movie_reviews.fileids('pos') + movie_reviews.fileids('neg')
    for file_id in file_ids:
        print(movie_reviews.words(file_id)[:5])
    
if __name__ == '__main__:
    main()</code></pre>

	<p>If we just wanted the first element:</p>
	<pre><code class="language-python">for file_id in file_ids:
    print(movie_reviews.words(file_id)[0]</code></pre>
	<p>Or the last element:</p>
	<pre><code class="language-python">for file_id in file_ids:
    print(movie_reviews.words(file_id)[-1]</code></pre>
	<p>The other basic data structure you ought to be familiar with is the dictionary, which are enclosed by curly bracks <code>{}</code> and are organised in terms of key value pairs. Let's write a function converting movie_reviews data into a dictionary to understand what this means:</p>
	<pre><code class="language-python">import nltk
nltk.download('movie_reviews')
from nltk.corpus import movie_reviews


def convert_to_dict():

    sentiment = ['pos', 'neg']
    d = {}
    for s in sentiment:
        file_ids = movie_reviews.fileids(s)
	for i, file_id in enumerate(file_ids):
	    d[f'{s}_{i}'] = {}
	    d[f'{s}_{i}']['content'] = ' '.join(movie_reviews.words(file_id))
	    d[f'{s}_{i}']['sentiment'] = s
    
    return d


def main():
	    
#    print(movie_reviews.fileids('pos'))
#    print(movie_reviews.fileids('neg'))
#    file_ids = movie_reviews.fileids('pos') + movie_reviews.fileids('neg')
#    for file_id in file_ids:
#        print(movie_reviews.words(file_id)) 
    d = convert_to_dict()
    print(d['neg_0'])


if __name__ == '__main__':
    main()</code></pre>
	
	<div class="back-to-top"><a href="#top">↑ Back to top</a></div>

       	</div> 

	<!-- links -->
	<div class="links">
	    <a href="https://github.com/ayanyuegupta">github</a>
	    <a href="https://www.instagram.com/ayanyuegupta/">instagram</a>
	    <a href="https://www.youtube.com/channel/UClNL5hp3ENN-B0owGvb4dpw">youtube</a>
	</div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    </body>
</html>
